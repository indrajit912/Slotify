# app/models/booking.py
# 
# Author: Indrajit Ghosh
# Created On: May 10, 2025
# 
import uuid
from datetime import datetime

import pytz

from app.extensions import db

IST = pytz.timezone("Asia/Kolkata")
UTC = pytz.utc

class TimeSlot(db.Model):
    __tablename__ = 'timeslot'

    id = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(db.String(36), unique=True, nullable=False, default=lambda: uuid.uuid4().hex)
    machine_id = db.Column(db.Integer, db.ForeignKey('washingmachine.id'), nullable=False)
    slot_number = db.Column(db.Integer, nullable=False)  # 1, 2, 3, 4
    time_range = db.Column(db.String(20), nullable=False, default="00:00-00:00")

    start_hour = db.Column(db.Time, nullable=False)
    end_hour = db.Column(db.Time, nullable=False)

    machine = db.relationship("WashingMachine", back_populates="time_slots")
    bookings = db.relationship("Booking", back_populates="time_slot", cascade="all, delete-orphan")

    def update_hours_from_range(self):
        """
        Parses the time_range string (e.g. "09:00-11:00") and sets start_hour and end_hour.
        """
        try:
            start_str, end_str = self.time_range.split('-')
            self.start_hour = datetime.strptime(start_str.strip(), "%H:%M").time()
            self.end_hour = datetime.strptime(end_str.strip(), "%H:%M").time()
        except ValueError as e:
            raise ValueError(f"Invalid time_range format '{self.time_range}': {e}")

    def to_json(self):
        return {
            "uuid": self.uuid,
            "slot_number": self.slot_number,
            "machine_uuid": self.machine.uuid if self.machine else None,
            "time_range": self.time_range
        }
    
    @classmethod
    def from_json(cls, data, machine_lookup):
        machine = machine_lookup.get(data["machine_uuid"])
        if not machine:
            raise ValueError(f"Machine with UUID {data['machine_uuid']} not found for TimeSlot import")

        start_str, end_str = data["time_range"].split('-')
        start_hour = datetime.strptime(start_str, "%H:%M").time()
        end_hour = datetime.strptime(end_str, "%H:%M").time()

        return cls(
            uuid=data["uuid"],
            machine=machine,
            slot_number=data["slot_number"],
            time_range=data["time_range"],
            start_hour=start_hour,
            end_hour=end_hour
        )


class Booking(db.Model):
    __tablename__ = 'booking'

    id = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(db.String(36), unique=True, nullable=False, default=lambda: uuid.uuid4().hex)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    time_slot_id = db.Column(db.Integer, db.ForeignKey('timeslot.id'), nullable=False)
    date = db.Column(db.Date, nullable=False)

    user = db.relationship("User", back_populates="bookings")
    time_slot = db.relationship("TimeSlot", back_populates="bookings")

    __table_args__ = (
        db.UniqueConstraint('time_slot_id', 'date', name='unique_slot_per_day'),
    )

    def to_json(self):
        """
        Convert the Booking instance into a JSON-serializable dictionary.

        Returns:
            dict: A dictionary representation of the booking, including:
                - uuid (str): UUID of the booking.
                - user_uuid (str): UUID of the associated user.
                - time_slot_uuid (str): UUID of the associated time slot.
                - date (str): Booking date in ISO format (YYYY-MM-DD).
        """
        return {
            "uuid": self.uuid,
            "user_uuid": self.user.uuid if self.user else None,
            "time_slot_uuid": self.time_slot.uuid if self.time_slot else None,
            "date": self.date.isoformat() if self.date else None,
        }

    @classmethod
    def from_json(cls, data, user_lookup, time_slot_lookup):
        """
        Create a Booking instance from a JSON dictionary.

        Args:
            data (dict): JSON dictionary typically generated by `to_json()`.
            user_lookup (dict): Mapping of user UUID (str) to User instances.
            time_slot_lookup (dict): Mapping of time slot UUID (str) to TimeSlot instances.

        Returns:
            Booking: A new Booking instance with attributes populated from `data`,
                     including valid User and TimeSlot instances resolved via lookups.
                     The instance is not yet added to the database session.

        Raises:
            ValueError: If the user_uuid or time_slot_uuid is not found in the respective lookup dictionaries.
        
        Usage:
            Prepare the lookups before import:
                users = User.query.all()
                user_lookup = {u.uuid: u for u in users}
                slots = TimeSlot.query.all()
                time_slot_lookup = {ts.uuid: ts for ts in slots}

            Then import:
                booking = Booking.from_json(json_data, user_lookup, time_slot_lookup)
        """
        def parse_dt(key):
            val = data.get(key)
            return datetime.fromisoformat(val) if val else None
        
        user = user_lookup.get(data["user_uuid"])
        if not user:
            raise ValueError(f"User with UUID {data['user_uuid']} not found for Booking import")

        time_slot = time_slot_lookup.get(data["time_slot_uuid"])
        if not time_slot:
            raise ValueError(f"TimeSlot with UUID {data['time_slot_uuid']} not found for Booking import")

        return cls(
            uuid=data["uuid"],
            user=user,
            time_slot=time_slot,
            date=parse_dt("date"),
        )

